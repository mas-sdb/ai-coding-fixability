# モデル利用ガイド - 評価視点の使い分け

## 目次

- [このガイドの位置づけ](#このガイドの位置づけ)
- [基本方針](#基本方針単独利用が基本組み合わせは任意)
- [1. 4層（Semantic Layers）](#1-4層semantic-layers---言語エコシステムの構造的理解)
- [2. 9軸（Fixability Axes）](#2-9軸fixability-axes---aiの修正可能性の評価)
- [3. 7フェーズ（AI Verification Loop）](#3-7フェーズai-verification-loop---aiの検証プロセス)
- [4. 組み合わせ方](#4-組み合わせ方任意)
- [5. カスタマイズの原則](#5-カスタマイズの原則)
- [6. プロジェクト固有の評価軸への変換](#6-プロジェクト固有の評価軸への変換)
- [7. 変換プロセス](#7-変換プロセス---7つのステップ)
- [8. 変換プロセスのまとめ](#8-変換プロセスのまとめ)

---

## このガイドの位置づけ

このドキュメントは、Semantic 9 Axes（モデルの抽象軸）と、
プロンプトで使用している実務9軸の関係を理解したい高度ユーザー向けです。

通常の利用者は、提供されているプロンプトをそのまま使用すれば十分であり、
この変換プロセスを理解する必要はありません。

軸名がモデルと一致しないのは、Semantic Axes が抽象モデルであり、
実務軸はプロジェクト診断に最適化された再構成版であるためです。


本モデルは2つのドキュメントで構成されています：

1. [評価モデル](./model.md) - モデルの詳細定義
2. **このガイド** - モデルをどう使うか

**関連ドキュメント：**
- [設計哲学](./philosophy.md) - フレームワークの長期安定性の原則
- [思考プロセス](./model-thought-process.md) - このフレームワーク開発の背景にある思考の流れ

**このガイドの目的：**
- モデルの3つの視点（4層・9軸・7フェーズ）の独立性を説明
- 利用者ごとの推奨使用法を示す
- カスタマイズの原則を提示

---

## 基本方針：単独利用が基本、組み合わせは任意

本モデルは、利用者の目的に応じて必要な部分だけを取り出して使える柔軟性を持っています。

**利用者ごとの推奨：**
- 開発者 → **9軸（Fixability Axes）だけ** を使えば十分
- 研究者 → **4層（Semantic Layers）だけ** を使って議論できる
- AIエージェント設計者 → **7フェーズ（AI Verification Loop）だけ** を使って最適化できる
- 高度な利用者 → **4層×9軸×7フェーズ** を組み合わせて分析できる

どの視点も独立して成立しており、フレームワーク全体を理解する必要はありません。

---

## 1. 4層（Semantic Layers）- 言語エコシステムの構造的理解

**定義詳細：** 4. 4 層構造（意味論レイヤー）

4層は、言語エコシステムを構造的に理解するための理論的・研究的な視点です。

**4つの層：**
- **Core Layer（コア層）** - 言語仕様、型システム、基本構文
- **Service Layer（サービス層）** - コンパイラ、ツールチェーン、開発支援ツール
- **Dependency Layer（依存関係層）** - 依存関係管理、パッケージエコシステム
- **Community Layer（コミュニティ層）** - 共有知識、ベストプラクティス、コミュニティ文化

### 4層の適用領域

**向いている用途：**
- 言語間の比較分析
- 言語設計思想の理解
- エコシステムの歴史的背景の分析
- 研究・論文・教育

**注意点：**
現場での診断には必須ではありません。理論的な背景を理解したい場合に使用してください。

---

## 2. 9軸（Fixability Axes）- AIの修正可能性の評価

**定義詳細：** 9 軸 × 2 次元モデル（実装 / 実行時）

9軸は、プロジェクト単位でAIの修正可能性を診断するための実務的ツールです。

**9つの評価軸：**

1. **Public Knowledge（公開知識）** - 訓練データとしての質と量、初期生成に影響
2. **Static Semantics（静的意味論）** - 実装時意味論検証の品質
3. **Spec Conformance（仕様適合性）** - 言語仕様の一貫性
4. **Tool Support（ツールサポート）** - 開発ツールの充実度
5. **Error Clarity（エラーの明確さ）** - エラーメッセージの質
6. **Runtime Continuity（実行時継続性）** - 実装時と実行時の一貫性
7. **Dependency Management（依存関係管理）** - パッケージ管理の品質
8. **Environment Semantics（環境意味論）** - 環境設定の明確さ
9. **Runtime Semantics（実行時意味論）** - 実行時の挙動の明確さ

### 9軸の適用領域

**向いている用途：**
- プロジェクトごとの言語診断
- AGENT.md / instructions.md の設計
- 依存関係更新時の再評価
- 実務的なFixability改善

**推奨：**
現場では9軸だけを使用すれば十分です。4層の理論的背景を理解していなくても診断できます。

---

## 3. 7フェーズ（AI Verification Loop）- AIの検証プロセス

**定義詳細：** [model.md - セクション4.1](./model.md#41-7フェーズの定義)

7フェーズは、AIがコードを生成し、検証し、修正するプロセスを分解したものです。

**検証ループの7段階：**

```
① 静的知識（事前知識）
   - AI の訓練データ、言語仕様、一般的なパターン

② 生成（初期生成）
   - AI による初回コード生成

③ 静的意味論検証
   - 型チェック、構文検証、linter
   - 失敗 → ⑦へ

④ 起動チェック
   - ビルド、依存関係の解決、起動確認
   - 失敗 → ⑦へ

⑤ テスト実行
   - ユニットテスト、統合テスト

⑥ 実行時フィードバック
   - テスト結果、エラーメッセージ、トレース
   - 成功 → 終了 / 失敗 → ⑦へ

⑦ 再生成（修正的生成）
   - フィードバックを基に修正
   - → ③に戻ってループ
```

### 7フェーズの適用領域

**向いている用途：**
- AIエージェントの設計
- 修正ループの改善
- プロンプト設計
- 実行時フィードバックの最適化

**注意点：**
言語診断そのものには必須ではありません。AIエージェントの挙動を理解・改善したい場合に使用してください。

---

## 4. 組み合わせ方（任意）

必要に応じて、以下のように組み合わせることもできます。

### A. 9軸 × 7フェーズ（現場向け）

**目的：**
どの軸が、どのフェーズで、修正の障害となるかをマッピングする。

**成果物：**
プロジェクト固有の修正可能性マップ

**使用例：**
- Public Knowledge（軸1）が 静的知識フェーズ（①）で不足している
- Error Clarity（軸5）が 静的意味論検証フェーズ（③）で不明確
- Runtime Continuity（軸6）が 実行時フィードバック（⑥）で不一致

### B. 4層 × 9軸（研究向け）

**目的：**
どの層の揺らぎが、どの軸に現れるかを分析する。

**成果物：**
言語エコシステムの構造的理解

**使用例：**
- Community Layerの揺らぎ → Public Knowledge（軸1）の低下
- Service Layerの不備 → Error Clarity（軸5）の低下
- Dependency Layerの不安定性 → Dependency Management（軸7）の低下

### C. 4層 × 7フェーズ（AIエージェント設計向け）

**目的：**
どの層の情報が、どのフェーズで必要かを整理する。

**成果物：**
AIエージェントの情報取得戦略

**使用例：**
- 静的知識フェーズ（①） → Community Layer
- 静的意味論検証フェーズ（③） → Core + Service Layer
- 起動チェックフェーズ（④） → Dependency Layer

### D. 4層 × 9軸 × 7フェーズ（高度な分析）

**目的：**
言語・エコシステム・AIの推論プロセスを統合的に分析する。

**成果物：**
包括的な修正可能性分析

**使用例：**
言語設計者、研究者、AIツール開発者が協働で言語エコシステムを改善する際に使用。

---

## 5. カスタマイズの原則

このフレームワークは、どのようにアレンジしても構いません。
ただし、以下の4つの原則を守れば、フレームワークの一貫性は保たれます。

### 原則1: Fixability（修正可能性）を中心に置く

評価の焦点は常に「AIが間違いを修正できるか」です。
初回生成品質ではなく、修正ループの収束性を評価してください。

### 原則2: 意味論情報の透明性を評価する

言語の「何を評価するか」ではなく「AIに何が伝わるか」を評価してください。
エラーメッセージ、型情報、ドキュメントの明確さが重要です。

### 原則3: 言語の価値観を評価軸にしない

静的型付けvs動的型付け、オブジェクト指向vs関数型といった価値観の対立を評価に持ち込まないでください。
どの価値観も「意味論の提供方法」として等しく扱います。

### 原則4: スコアリングやランキングを行わない

このフレームワークは言語の優劣を決めるものではありません。
各言語の特性を理解し、プロジェクトに適した選択をするためのツールです。

---

## まとめ（基本編）

このフレームワークは、4層・9軸・7フェーズのどれか1つだけでも使えるように設計されています。

**利用者ごとの推奨：**
- **現場の開発者** → 9軸だけを使用
- **研究者** → 4層だけを使用
- **AIエージェント設計者** → 7フェーズだけを使用
- **高度な分析** → 組み合わせ自由

この柔軟性こそが、AI時代の言語エコシステム評価モデルの最大の強みです。

---

## 実践ツール

このモデルを実際に使用するためのツール：

### diagnostic_prompt.md
- 9軸に基づく言語診断プロンプト（実プロジェクト利用に合わせて調整済み）
- 任意の AI モデルで使用可能
- 使い方の詳細：[diagnostic_prompt.md](./diagnostic_prompt.md)

### 診断結果の活用
診断結果を基に、AGENT.mdやinstructions.mdを設計し、プロジェクト固有の修正可能性を向上させることができます。

---

## 6. プロジェクト固有の評価軸への変換

このセクションでは、理論的な**Semantic 9 Axes**を、実際のプロジェクト診断に使える**実務9軸**に変換する方法を説明します。

### なぜ変換が必要なのか

Semantic 9 Axes（本モデルの評価軸）は、AIの推論構造を分析するための抽象的な意味論モデルです。
しかし、実務では以下が必要になります：

- **プロジェクト固有の誤推論を分類できる軸**
- **チームが理解しやすい軸**
- **AGENT.md や instructions.md に落とし込める軸**

そのため、Semantic 9 Axes を実務向けに再構成する変換プロセスが必要になります。

**注意：**
モデルの軸をそのまま利用しても構いませんが、抽象度が高い回答が得られる場合があります。
プロジェクト固有の文脈に合わせて軸を再定義することで、より具体的で実用的な診断が可能になります。

---

## 7. 変換プロセス - 7つのステップ

### ステップ1: 抽象概念を「誤推論の原因」に変換する

Semantic Axes は抽象的なので、まずはそれを**「AIが誤推論する原因」**に変換します。

**例：**
- Public Knowledge → 情報の鮮度・品質の揺れ
- Static Semantic Consistency → 型・構造の整合性
- Runtime Semantic Continuity → 実行時の状態・非同期・ランタイム差異

**目的：抽象概念を"誤推論の源泉"として再定義する**

---

### ステップ2: 誤推論が現場でどう現れるかを観察する

次に、抽象的な誤推論原因が**実際のプロジェクトでどのように現れるか**を具体化します。

**例：**
- コミュニティの流派差で AI が別パターンを混ぜる
- ドキュメントのバージョン差で AI が古い API を使う
- 実行時の挙動を誤解して危険なコードを生成する

**目的：抽象 → 具体の橋渡し**

---

### ステップ3: 具体的な誤推論を"現場で扱いやすいカテゴリ"に再編成する

**これが最も重要なステップです。**

観察した誤推論を、**現場で理解しやすく、診断しやすいカテゴリ**に再編成します。

**例：**
- コミュニティの流派差 → Community Consistency
- ドキュメントのバージョン差 → Documentation Consistency
- 実行時の挙動差 → Runtime Semantic Service

**目的：抽象モデルを実務モデルに変換する**

---

### ステップ4: 軸名は自由に変えてよい（本質は分類内容）

軸名はただのラベルなので、**プロジェクトにとって理解しやすい名前に変えて構いません。**

Semantic Axes の意味さえ保持していれば、軸名は自由に変えて問題ありません。

**例：**
- Semantic Metadata Richness → Documentation Consistency
- Semantic Extensibility → API Consistency

**目的：現場で使いやすい軸にする**

---

### ステップ5: Semantic Axes と実務軸のマッピングを作る

最終的に、Semantic Axes と実務軸の対応表を作ります。

**マッピング表の例：**

| Semantic 9 Axes（抽象） | 実務 9 軸（具体例） | 変換の意味 |
|-------------------------|---------------------|------------|
| **1. Public Knowledge** | **Community Consistency** | コミュニティの知識の揺れ・流派差・古い情報の混在 |
| **2. Static Semantics** | **Static Semantic Service** | 型・構造・依存関係の静的整合性 |
| **3. Metadata Richness** | **Documentation Consistency** | アノテーション・コメント・公式ドキュメントの整合性 |
| **4. Access & Automation** | **Ecosystem Consistency** | DI、ビルド、パイプライン、ツールチェーンの暗黙挙動 |
| **5. Runtime Continuity** | **Runtime Semantic Service** | 実行時の状態・非同期・ランタイム差異 |
| **6. Dependency Stability** | **Dependency Stability** | 依存関係の更新頻度・互換性（そのまま） |
| **7. Spec Conformance** | **Ecosystem Consistency（一部）** | OS・クラウド・ホスティングの仕様差異 |
| **8. Compatibility Culture** | **Practice Consistency** | レガシー文化・旧パターン・現場流儀の差異 |
| **9. Semantic Extensibility** | **API Consistency** | DSL、拡張メソッド、イベント、パイプラインの意味論拡張 |

**注意：**
これはあくまで一例です。プロジェクトの特性に応じて、軸名や分類は自由に変更してください。

---

### ステップ6: プロジェクトに合わせて微調整する

プロジェクト固有の要素（言語、フレームワーク、アーキテクチャ）に合わせて実務軸を微調整します。

**例：**

**C#/.NET プロジェクトの場合：**
- DI / Middleware / Entity Framework Core / Azure の暗黙挙動
- ASP.NET Core の設定規約
- NuGet パッケージの更新パターン

**Java/Spring プロジェクトの場合：**
- AOP / Bean / Hibernate / Tomcat の暗黙挙動
- Spring Boot の自動設定
- Maven/Gradle の依存関係解決

**Python プロジェクトの場合：**
- 型ヒントの部分適用
- pip/conda の依存関係
- 実行時の動的型付け

**目的：プロジェクト固有の誤推論を拾える軸にする**

---

### ステップ7: プロジェクト診断レポートを作成する

最終的に、変換した実務9軸を使って**プロジェクト診断レポート**を作成します。

このレポートは、AIが誤推論しやすいポイントと、その緩和策を文書化したものです。

---

#### 7-1. レポートの目的

プロジェクト診断レポートは以下の目的で作成します：

1. **AI誤推論ポイントの可視化**
   - プロジェクト固有の誤推論リスクを特定
   - チーム全体で共有

2. **緩和策の文書化**
   - AGENT.md や instructions.md への記載内容の元ネタ
   - コーディング規約への反映

3. **診断結果の記録**
   - 依存関係更新時の再評価の基準
   - 時間経過による変化の追跡

#### 7-2. レポート作成のポイント

**重要な方針：**

1. **定量評価を避ける**
   - ⭐評価やスコアは使用しない
   - 「優れている」「改善の余地あり」などの定性的表現

2. **構造的観察に基づく**
   - 価値判断ではなく、構造的な事実
   - AIの推論プロセスへの影響

3. **実践的な緩和策**
   - 具体的で実行可能なアクション
   - 実装場所を明示（AGENT.md、instructions.md等）

4. **継続的な更新**
   - 依存関係更新時に再評価
   - 新しい誤推論パターンの追加

---

#### 7-3. レポートの活用方法

作成した診断レポートは以下のように活用します：

**AGENT.md への反映:**
````markdown
# プロジェクト固有のガイドライン

## 使用するパターン
- ASP.NET Core Web API（Minimal API は使用しない）
- Entity Framework Core（Database First を使用）

## 注意事項
- Nullable参照型は有効（.csproj で <Nullable>enable</Nullable>）
- C# 14 の機能を積極的に使用
````

**コーディング規約への反映:**
````markdown
# ASP.NET Core 実装規約

## API設計
- ✅ コントローラーベースを使用
- ❌ Minimal APIを使用しない

## Entity Framework
- ✅ Database First を使用
- ❌ Code First は使用しない
````

**依存関係更新時のチェックリスト:**
````markdown
- [ ] 診断レポートを再確認
- [ ] 新しい誤推論パターンがないか検証
- [ ] AGENT.mdの更新が必要か確認
````

---

## 8. 変換プロセスのまとめ

```
1. Semantic Axes の抽象概念を理解する
2. それが生む誤推論を具体化する
3. 誤推論を現場で扱いやすいカテゴリに再編成する
4. 軸名は自由に変えてよい（本質は分類内容）
5. Semantic Axes と実務軸のマッピングを作る
6. プロジェクト固有の要素で微調整する
7. 実務9軸診断テンプレートとして完成させる
```

**重要な原則：**
- Semantic 9 Axes は「理論的な基盤」
- 実務9軸は「プロジェクト固有の適用」
- 両者は1対1対応である必要はない
- プロジェクトの文脈に合わせて自由にカスタマイズ可能

---

## まとめ（変換プロセス編）

このモデルは、以下の3つのレベルで利用できます：

**レベル1: そのまま使う**
- Semantic 9 Axes をそのまま診断に使用
- 抽象的だが汎用性が高い

**レベル2: 軽くカスタマイズ**
- 軸名をプロジェクトに合わせて変更
- 評価基準を具体化

**レベル3: 完全にカスタマイズ**
- ステップ1-7に従って実務9軸を再定義
- プロジェクト固有の診断テンプレートを作成

どのレベルで使用するかは、プロジェクトの規模、チームの習熟度、診断の目的によって選択してください。
