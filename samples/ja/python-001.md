# python 診断結果サンプル
- モデル：GPT-5.2
- 入力データ

```
## 入力として与える情報
- 言語名 python
```

# 診断結果
Community Consistency

AI の誤推論ポイント：
- 仮想環境の流儀（venv / virtualenv / conda）やパッケージ管理（pip / Poetry / uv / pip-tools）が混在し、プロジェクトの前提と異なる手順・構成を提案しがち
- テスト（unittest / pytest）、ログ（logging の使い方）、設定管理（dotenv / pydantic-settings 等）など「よくあるやり方」が複数あり、文脈違いを起こしやすい
- “Python ならこうする” の一般論（スクリプト直置き、グローバル実行、相対 import 乱用）を持ち込みやすい

AI に与えるべき対策：
- 「採用ツールチェーン」を明記（例：venv + pip、Poetry、uv、conda のどれか／実行コマンド）
- テスト・lint・format・型チェックの標準を固定（pytest / ruff / black / mypy or pyright 等）
- プロジェクトのディレクトリ規約（src レイアウト有無、import 方針、エントリポイント）を AGENT.md に明文化


Documentation Consistency

AI の誤推論ポイント：
- Python バージョン差（3.8〜3.12 など）で標準ライブラリや typing の仕様・推奨が変わるのに、別バージョンのドキュメントを参照して提案しがち
- 公式ドキュメント、PEP、ブログ記事、ライブラリ README の推奨が食い違い、古い慣習（setup.py 前提など）を持ち込みやすい
- “同名の機能” が複数存在（例：設定、CLI、HTTP クライアント等）し、別物のドキュメントを混ぜやすい

AI に与えるべき対策：
- 対象 Python バージョン範囲を明記（例：3.11 固定／3.10–3.12 サポート）し、CI でも検証
- 参照すべき一次情報（公式 docs の該当バージョン、採用ライブラリの公式 docs）をリンク一覧化
- 「採用しない」仕組み（例：setup.py 直編集しない、特定の設定手法は使わない）も明示


Practice Consistency

AI の誤推論ポイント：
- モジュール構成（単一ファイル・パッケージ化・src/ 配下）が揺れやすく、import エラーや循環参照を誘発する提案をしがち
- 例外設計・戻り値設計（None / 例外 / Result 的表現）や、データ構造（dataclass / pydantic / dict）の選択がプロジェクト流儀とズレやすい
- “Pythonic” という曖昧な基準で、可読性より短さ優先の提案になりがち

AI に与えるべき対策：
- パッケージ境界・依存方向・import 規約（絶対 import、相対 import 可否）を明文化
- 例外方針（どこで握りつぶすか、独自例外の命名規約）と戻り値方針を記載
- 採用データモデル（dataclass / attrs / pydantic 等）と用途（入出力、内部表現）を定義


Dependency Stability

AI の誤推論ポイント：
- Python は依存関係更新が速く、同じライブラリでもメジャー更新で破壊的変更が起きやすいのに、最新前提の API を提案しがち
- OS/アーキ依存（C 拡張、ビルド要件）を軽視して、ローカルでは動くが CI/本番で壊れる依存追加を提案しがち
- lock なし運用を前提にして “pip install …” を積み上げ、再現性を壊しがち

AI に与えるべき対策：
- 依存の固定戦略（lockfile の必須、上限制約、constraints）を明記
- “新規依存追加” の判断基準（可否、レビュー要件、代替として標準ライブラリ優先など）をルール化
- 対象 OS/実行環境（Linux/Windows/macOS、Docker 有無）とビルド要件の前提を記載


API Consistency

AI の誤推論ポイント：
- 同名概念の API が乱立（sync/async、bytes/str、pathlib/os.path、datetime/pendulum 等）し、プロジェクトの採用 API と違う呼び出しを混ぜやすい
- 例外型・戻り値・ミュータブル/イミュータブルの扱いを誤り、静かにバグる提案（破壊的変更、デフォルト引数罠など）をしがち
- typing の導入度（厳格/緩い）により、期待される関数シグネチャや Nullable の扱いがズレやすい

AI に与えるべき対策：
- 標準採用 API（例：pathlib を使う、datetime は timezone 必須など）を列挙
- “境界層” の規約（I/O、外部 API、DB 層では型・例外・エンコードをどう扱うか）を明確化
- 型チェック方針（mypy/pyright の設定、strict 度、Optional の扱い）を共有


Ecosystem Consistency

AI の誤推論ポイント：
- ビルド/配布（setuptools / Poetry / Hatch / Flit）、実行（python -m、entry points）、設定（pyproject.toml か別ファイルか）などツールチェーン差が大きく、別流派の手順を提案しがち
- Web/非Web、WSGI/ASGI、asyncio の有無などで設計が変わるのに、前提を取り違えて構成を提案しがち
- 既存の lint/format 設定（ruff/flake8/isort/black）の組合せを崩しやすい

AI に与えるべき対策：
- 採用ツール（ビルドバックエンド、タスク実行、CI）を固定し、コマンドをそのまま貼れる形で提示
- async 方針（使う/使わない、使う場合の境界）を明記
- 既存の設定ファイル（pyproject.toml 等）を「唯一の正」とし、追加・変更の手順をルール化


Static Semantic Service

AI の誤推論ポイント：
- Python の型情報は任意で、実装と型注釈が乖離している可能性があり、型だけ見て誤った前提で提案しがち
- ライブラリの型スタブ不足・不整合により、AI が“型がある前提”で設計を固めてしまいがち
- 動的機構（__getattr__、デコレータ、メタクラス等）で静的解析が効きにくい箇所を読み違えやすい

AI に与えるべき対策：
- 型チェックツールと厳格度、型注釈の必須範囲（公開 API のみ等）を明記
- “型で保証するもの/テストで保証するもの” の境界を定義
- 静的解析で追えない仕組みを使っている箇所（動的 import、プラグイン機構等）をドキュメント化


Runtime Semantic Service

AI の誤推論ポイント：
- 動的型・duck typing により、実行時まで失敗が遅延し、AI が「動くはず」と誤認しやすい
- 例外が多様で、握りつぶし・再送出・ログ粒度の方針が曖昧だと、運用上危険なハンドリングを提案しがち
- タイムゾーン、ロケール、ファイルエンコーディング、並行実行（スレッド/プロセス/async）など実行環境依存の罠を見落としやすい

AI に与えるべき対策：
- 例外処理方針（捕捉する例外、ログ、再試行、ユーザー向けエラー）を規約化
- 実行環境の前提（OS、TZ、encoding、コンテナ有無）と再現手順を明示
- 重要ロジックはテスト種別（unit/integration）と観測（ログ/メトリクス）をセットで要求するルールにする


Core Semantic Consistency

AI の誤推論ポイント：
- Python は後方互換を重視しつつも、バージョンごとに構文・標準ライブラリ・typing が段階的に変化し、AI が別バージョンの常識を混ぜやすい
- “できてしまう” 曖昧さ（暗黙の型変換は少ないが、動的属性追加や可変デフォルト引数など）があり、微妙なバグを含む提案になりがち
- 実装依存（CPython 前提の挙動、パフォーマンス特性）を暗黙に置きやすい

AI に与えるべき対策：
- 対象 Python 実装（通常は CPython）とサポートバージョンを明記し、CI で固定
- 禁止パターン（可変デフォルト引数、曖昧な日時、暗黙の str/bytes 混在等）をチェックリスト化
- パフォーマンス/並行性の前提（GIL を踏まえた設計、I/O は async か等）をプロジェクト方針として明文化